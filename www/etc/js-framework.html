<h1 id="is-htmx-just-another-javascript-framework">Is htmx just another
JavaScript framework?</h1>
<p>One objection people raise when they first hear about htmx is the
following:</p>
<blockquote>
<p>You’re complaining about the complexity of modern frontend
frameworks, but your solution is just another complex frontend
framework.</p>
</blockquote>
<p>This is an excellent objection! It’s the right to question to ask
about <em>any</em> third-party (3P) code that you introduce into your
project. Even though you aren’t writing the 3P code yourself, by
including it in your project you are committing to
<em>understanding</em> it for as long as you rely on it—and that
understanding will have to be updated if you upgrade it. That’s a big
commitment.</p>
<p>Let’s break this question down into its constituent parts, and
determine exactly how much htmx indulges in the harms it claims to
solve.</p>
<h2 id="the-difference-between-a-library-and-a-framework">The difference
between a library and a framework</h2>
<p>Some htmx defenders jump to our aid with: “htmx isn’t a framework,
it’s a library.” This is probably incorrect.</p>
<p>“Framework” is a colloquial term—there’s no hard rule for the point
at which some third-party code evolves from a “library” into a
“framework”—but we should still try to define it. In this context:</p>
<ul>
<li><strong>Library</strong> - 3P code whose API does not significantly
influence the rest of the application</li>
<li><strong>Framework</strong> - 3P code whose API dictates the overall
structure of the application</li>
</ul>
<p>If you prefer metaphors: a library is a cog that you add to your
machine, a framework is a pre-built machine that you control by
customizing its cogs.</p>
<p>This distinction, fuzzy though it may be, is important because it
describes how easily some third-party code can be replaced. For example,
a JavaScript service that uses a CSV parsing library can probably swap
in a different CSV parsing library without too much trouble; a
JavaScript service that uses the NextJS framework, however, is probably
going to depend on NextJS for its entire useful life, since an enormous
chunk of the code assumes that it’s interacting with NextJS
constructs.</p>
<p>Therefore, if your service is built atop a framework, you have agreed
to tie the useful lifespan of your project to the useful lifespan of
that framework. If that framework is abandoned, or hated, or otherwise
undesirable to work on, the difficulty of modifying your project will
steadily increase until you give up modifying it, and eventually,
mothball it altogether.</p>
<p>That’s what people are worried about when they ask is “is htmx just
another JavaScript framework?” They want to be sure that they’re not
committing to a system that will be quickly made obsolete, like so many
of the past web development frameworks.</p>
<p>So: is htmx a framework? And is it going to be made quickly obsolete,
leaving a trail of un-maintainable websites in the wake of its meteoric
demise?</p>
<h2 id="htmx-is-usually-a-framework">htmx is (usually) a framework</h2>
<p>With apologies to our discord channel dedicated to debating this
question—I think htmx is pretty clearly a framework, at least in the
majority use-case.</p>
<p>Wherever you make use of htmx in your project, you’re including htmx
attributes in your HTML (i.e. <code>hx-post</code>,
<code>hx-target</code>), writing endpoints that are called with
htmx-formatted data (with certain request headers, in particular), and
returning data from those endpoints that is formatted in ways that htmx
expects (HTML with <code>hx-*</code> controls). All of these attributes
and headers interact with each other to create a system by which
elements enter and exit the DOM after a network request.</p>
<p>If you use htmx to handle a non-trivial number of your website’s
network requests, then the inclusion of htmx in your application has
significant implications for the project’s structure, from the frontend
HTML attributes, to the database queries your endpoints make. That is
framework-like behavior, and in that scenario, htmx cannot be trivially
replaced.</p>
<p>You can definitely use htmx in a library-like manner, to add dynamic
functionality to just a few sections of your web page. But you can write
<a href="https://www.patterns.dev/vanilla/islands-architecture">React in
this library-like manner too</a> and nobody says that React isn’t a
framework. The vast majority of people writing their applications in
htmx are doing so in a way that bends to the demands of htmx, as a
framework for building hypermedia applications.</p>
<p>As they should! Building with htmx works a lot better if you play to
its strengths. You can send JSON-formatted form bodies, if you <a
href="https://htmx.org/extensions/json-enc/">really insist</a>. But you
shouldn’t! It’s simpler to just use
<code>application/x-www-form-urlencoded</code> bodies, and write an
endpoint that accepts them. You can write an endpoint that is re-used
across multiple different clients. <a
href="https://htmx.org/essays/why-tend-not-to-use-content-negotiation/">But
you shouldn’t!</a> It’s simpler to split your <a
href="https://htmx.org/essays/splitting-your-apis/">data and your
hypermedia APIs</a> into separate URLs. Yes, htmx can be used as a
library, but let it be your framework. It’ll be fine.</p>
<p>That does not mean, however, that htmx is Just Another JavaScript
Framework, because htmx has a huge advantage that the other frameworks
do not: HTML.</p>
<h2
id="htmx-is-not-a-framework-for-writing-javascript-its-a-framework-for-writing-html">htmx
is not a framework for writing JavaScript; it’s a framework for writing
HTML</h2>
<p>Let’s say you’re using htmx as a framework—is it a
<em>JavaScript</em> framework? In one obvious sense, yes: htmx is
implemented with ~4k lines of JS. But in another, much more important
sense, it is not: React, Svelte, Solid, and so on have you write JS(X)
that the framework converts into HTML; htmx just has you write HTML.
This removes entire categories of maintenance that might make you
abandon other frameworks with time.</p>
<p>One thing that causes codebases to get stuck is when you want to
upgrade or change some dependency, but the framework you use is
incompatible with that change. Java is the most notorious offender
here—there are untold millions of lines of Java in production that will
never leave Java 8 because upgrading Spring is too hard—but the npm
package ecosystem is a close second. When you use the htmx “framework”
you will never have this problem, because htmx is a <a
href="https://htmx.org/essays/no-build-step/">zero-dependency,
client-loaded JavaScript file</a>, so it is guaranteed to never conflict
with whatever build process or dependency chain your server
<em>does</em> depend on.</p>
<p>Browsers render HTML, so no compiler or transpiler is ever necessary
to work with htmx. While many htmx users happily render API responses
with JSX, htmx works very well with <a
href="https://jinja.palletsprojects.com">classic</a> <a
href="https://ejs.co/">template</a> <a
href="https://docs.ruby-lang.org/en/2.3.0/ERB.html">engines</a>, making
it portable to <a
href="https://htmx.org/essays/hypermedia-on-whatever-youd-like/">whatever
language you like</a>. Say what you will about Django and Rails, but
they were relevant in 2008 and they’re relevant today—htmx integrates
seamlessly with them both. This is a recurring theme with htmx-driven
development: htmx works well with development tools old and new, because
the common denominator in all these tools is HTML, and htmx encourages
you to write HTML.</p>
<p>Pushing the user to define the behavior of their application
primarily in HTML, rather than JS, has too many advantages to cover in
this essay, so I’ll stick the ones that are most relevant to what people
hate about JavaScript fameworks. Depending on when you wrote your React
application, you might have written your form with <a
href="https://legacy.reactjs.org/docs/forms.html">controlled class
components</a>, or <a
href="https://blog.logrocket.com/react-hook-form-complete-guide/">react
hooks</a>, or this <a
href="https://react.dev/reference/react-dom/components/form">experimental
<code>&lt;form&gt;</code> extension</a>. This is genuinely maddening,
especially if you—like me—first learned how to make a web form with
class components.</p>
<p>No matter when you wrote your htmx application, however, a form has
always been just a <code>&lt;form&gt;</code>, and it’s always sent data
in the same format that regular HTML forms do. With htmx, you can
finally use <code>PUT</code> requests in your form, and control where
the response goes, but you are fundamentally doing something extremely
to the default <code>&lt;form&gt;</code> element. This is a much less
alienating way to learn web development, because the bulk of your
knowledge will remain relevant as long as HTML does.</p>
<p>Finally, because htmx simply extends HTML in a very narrow domain
(network requests and DOM replacements), most of the “htmx” you write is
just plain old HTML. When you have access to complex state management
mechanisms, it’s incredibly easy to implement a custom collapsable div;
when you don’t, you might stop long enough to search up the <a
href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/details"><code>&lt;details&gt;</code></a>
element. Whenever a problem can be solved by native HTML elements, the
longevity of the code you wrote improves tremendously as a result.</p>
<p>In short, while htmx is probably a framework, it’s a framework that
<a
href="https://unplannedobsolescence.com/blog/custom-html-has-levels/#custom-attributes-fill-the-semantic-deviation-gap">deviates
far less from the web’s semantics</a> than the JavaScript frameworks do,
and will benefit from improvements in those semantics with no additional
work from the user. It’s an extension to HTML, not a compiler for it. If
you want to build a website that lasts for a long time, with minimal
maintenance, these qualities make htmx a better bet than many of its
contemporaries.</p>
<p><em>NOTE: Despite agreeing with this analysis, finding no logical
flaw in the essay, and allowing me to publish it on his website, Carson
irrationally insists that htmx is a library.</em></p>
