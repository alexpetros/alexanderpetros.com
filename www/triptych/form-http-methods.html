<!DOCTYPE HTML>
<title>Support PUT, PATCH, and DELETE in HTML Forms</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">

<style>
:root {
  --page-background: white;
  --header-color: #039;
}

html {
  scrollbar-gutter: stable;
}

body {
  background-color: var(--page-background);
  font-family: Verdana;
  margin: 20px auto;
  max-width: 900px;
  padding: 0 20px;
  line-height: 1.3;
}

h1, h2, h3 {
  color: var(--header-color);
  font-weight: normal;
}

h1 {
  counter-reset: header-count;
}

h2 {
  counter-reset: subheader-count;
}

h2::before {
  counter-increment: header-count;
  content: counter(header-count) '. ';
}

h3::before {
  counter-increment: subheader-count;
  content: counter(header-count) '.' counter(subheader-count) '. ';
}

dt {
  font-weight: bold;
}

a:visited {
  color: blue;
}

details {
  border: 1px solid #aaa;
  border-radius: 4px;
  padding: 0.5em 0.5em 0;
}

details[open] summary {
  border-bottom: 1px solid #aaa;
  margin-bottom: 0.5em;
}

summary {
  font-weight: bold;
  user-select: none;
  margin: -0.5em -0.5em 0;
  padding: 0.5em;
}

summary:hover {
  background-color: lightgray;
}

ol {
  counter-reset: toc-count;
  list-style-type: none;
}

ol li::before {
  counter-increment: toc-count;
  content: counters(toc-count, '.', decimal) '. ';
}

pre.code {
  overflow: wrap;
  background-color: lightgray;
  padding: 10px;
}

p.footnote {
  background-color: var(--page-background);
  padding: 5px 0;
}

p.footnote:target {
  background-color: yellow;
}

</style>

<h1>Support PUT, PATCH, and DELETE in HTML Forms</h1>

<dl>
  <dt>Author</dt>
  <dd>Alexander Petros <a href="mailto:contact@alexpetros.com">(contact@alexpetros.com</a>)</dd>
  <dt>Date Created</dt>
  <dd>July xx, 2024
  <dt>Last Updated</dt>
  <dd>July xx, 2024
  <dt>Status</dt>
  <dd style="color: red;">Unpublished</dd>

</dl>

<details class=toc>
<summary>Table of Contents</summary>
<noscript>
  The table of contents is generated with JavaScript, which you have disabled.
</noscript>
</details>


<h2>Summary</h2>
<p>
A proposal for adding PUT, PATCH, and DELETE support to HTML forms.

<p>
Proposal 1/3 in the <a href=/triptych>Triptych Proposals</a>.

<h3>Goals</h3>
<p>
PUT, PATCH, and DELETE support in forms should:

<ul>
  <li>be the path of least friction for developing RESTful web services
  <li>integrate seamlessly with existing form semantics
  <li>integrate with existing servers and frameworks that support those methods
  <li>not introduce new security considerations
</ul>

<h2 id=proposed-changes>Proposed Changes</h2>
<p>
New values for the form <code>method</code> attribute:
<ul>
  <li><code>PUT</code> - makes the form issue a PUT request
  <li><code>PATCH</code> - makes the form issue a PATCH request
  <li><code>DELETE</code> - makes the form issue a DELETE request
</ul>

<p>
All new method keywords are case insensitive.
Existing form controls (e.g. <code>action</code>, <code>enctype</code>) should operate identically.

<h2 id=sample-usage>Sample Usage in Resource Lifecycle</h2>

This section demonstrates how PUT and DELETE methods are necessary for managing the lifecycle of a
resource. We use as an example a hypothetical hotel reservation service, in which users have the
ability to book hotel rooms.

<p>
All examples in this section assume that the host origin is https://example.com.

<h3 id=basic-create-form>Creating A Resource</h3>

First, the user makes a reservation using a traditional POST form:<f-note>While PUT is capable of
creating new resources, POST is preferred when the service
<q><a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-10">selects a proper URI on
behalf of the client.</a></q> This is the simplest RESTful pattern, and has the additional
benefit of using a non-idempotent method, so the browser can guard against double reservations.
More benefits to using this pattern will be discussed in the justifications section.
</f-note>

<code>
<pre class=code>
&lt;form action="/reservations" method="POST"&gt;
  &lt;input type="text" name="name"&gt;
  &lt;input type="date" name="check-in"&gt;
  &lt;input type="date" name="check-out"&gt;
  &lt;input type="checkbox" name="has-pets"&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>
</code>

The browser will send the following HTTP request:

<code>
<pre class=code>
POST /reservations HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
...
name=Alex%20Petros&check-in=2024-12-01&check-out=2024-12-02&has-pets=on
</pre>
</code>

And the server responds with a redirect to the newly-created reservation resource:<f-note>The
<a href="https://www.rfc-editor.org/rfc/rfc9110#section-15.4.4-1">303 SEE OTHER</a> status code is
used here because it directs the agent to make the subsequent request as GET, regardless of what
method the original request used. 302 FOUND does not do this this, but for historical reasons,
browsers <a href="https://www.rfc-editor.org/rfc/rfc9110#section-15.4.3-3.1">typically change POST
to GET</a>, while leaving PUT, PATCH, and DELETE methods as is. For this reason, we use 303 for
everything.
</f-note>

<code>
<pre class=code>
HTTP/1.1 303 SEE OTHER
Location: /reservations/123
</pre>
</code>


<h3 id=basic-put-form>Updating A Resource</h3>

<p>
At the reservation page, the user is presented with two forms. The first one allows them to adjust
their reservation:

<code>
<pre class=code>
&lt;form action="/reservations/123" method="PUT"&gt;
  &lt;input type="text" name="name" value="Alex Petros"&gt;
  &lt;input type="date" name="check-in" value="2024-12-01"&gt;
  &lt;input type="date" name="check-out" value="2024-12-02"&gt;
  &lt;input type="checkbox" name="has-pets" checked&gt;
  &lt;button&gt;Submit&lt;/button&gt;
&lt;/form&gt;
</pre>
</code>

This new form offers the same controls as the POST form, but with some key differences:

<ul>
  <li>The action has changed from <code>/reservations</code> to <code>/reservations/123</code>
  <li>The method has changed from <code>POST</code> to <code>PUT</code>
  <li>The forms are pre-filled with the values saved at the server.
</ul>

<p>
By presenting the user with both the current application state (the form values) and possible
actions on that state (the input types and submit button), HTML is able to fulfill its duty as a
uniform interface.<f-note>
This is sometimes called Hypertext as the Engine of Application State
(<a href="https://htmx.org/essays/hateoas/">HATEOAS</a>).
</f-note>

<p>
If the user changes the check-out date to <code>2024-12-03</code>, the browser will send the
following request:

<code>
<pre class=code>
PUT /reservations/123 HTTP/1.1
Host: example.com
Content-Type: application/x-www-form-urlencoded
...
name=Alex%20Petros&check-in=2024-12-01&check-out=2024-12-03&has-pets=on
</pre>
</code>

The server can then choose to either send back a new page or redirect to one.

<h3 id=basic-delete-form>Deleting A Resource</h3>

The second form on the reservation page allows the user to delete their reservation:

<code>
<pre class=code>
&lt;form action="/reservations/123" method="DELETE"&gt;
  &lt;button&gt;Delete Reservation&lt;/button&gt;
&lt;/form&gt;
</pre>
</code>

Clicking "Delete Reservation" would result in the following HTTP request:

<code>
<pre class=code>
DELETE /reservations/123 HTTP/1.1
Host: example.com
</pre>
</code>

And the server could choose to either send a delete confirmation page, or redirect elsewhere.


<h2>Additional Considerations</h2>
<h3 id=body-content>Body Content</h3>

<p>
PUT and PATCH forms should send identical content to their POST equivalents.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#appendix-B.3-5">"Content" was previously known
  as "payload"</a> or "payload body", and is set using the <code>body</code> property of a fetch
request.
</f-note>

All three methods support the same Content-Type headers, and they are differentiated from each
other based on the intent for the enclosed representation, not the representation itself.<f-note>
Per <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-put">RFC9110</a>, the difference
between POST and PUT <q>is highlighted by the different intent for the enclosed representation,</q>
which implies that they support the same set of representations. Per
<a href="https://www.rfc-editor.org/rfc/rfc5789">RF5789</a>, which defines PATCH, <q>the
difference between the PUT and PATCH requests is reflected in the way the server processes the
enclosed entity to modify the resource</q>, which again implies that they are capable of
representing resources the same way.
</f-note>
Most, if not all, servers that support PUT and PATCH handle their bodies identically to POST bodies,
so their addition to the supported form methods can be adopted by the ecosystem
immediately.<f-note>Citation needed.</f-note>

<p>
DELETE forms should format their content as URL parameters, like GET forms. While both GET and
DELETE body semantics are technically undefined, including content in the request body is somewhat
discouraged by the spec.<f-note>
While <a href="https://www.rfc-editor.org/rfc/rfc9110.html#name-delete">RFC9110</a> states that a
<q>DELETE request has no generally defined semantics,</q> it also states that <q>a client SHOULD NOT
generate content in a DELETE request unless it is made directly to an origin server that has
previously indicated, in or out of band, that such a request has a purpose and will be adequately
supported</q>. While one could certainly argue that the server returning HTML with <code>&lt;form
  method=DELETE&gt;</code> constitutes indication of support for content, we defer to the library
ecosystem, which generally understands the similar language in the GET and DELETE specs as a tacit
discouragement of body content for both.
</f-note>
Therefore, forms with <code>method=DELETE</code> should encode their inputs as part the URI,
emulating the behavior of forms with no <code>method</code>, or <code>method=GET</code>.

<h3>Caching</h3>
<p>
PUT, PATCH, and DELETE requests are <a href="https://httpwg.org/specs/rfc9110.html#safe.methods">
unsafe</a> (not read-only), and therefore can never be cached.

<p>
PATCH <em>responses</em> are technically cacheable in the same way that POST responses are: if
certain information is explicitly provided, subsequent GET requests may use the cached PATCH
response to represent that resource.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc5789#section-2">RFC 5789 Section 2</a>,
</f-note> Browsers that implement this behavior for POST requests should do so for PATCH requests,
although the spec notes that the overwhelming majority of cache implementations do not.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.2.3-2">RFC 9110 Section 9.2.3</a>,

<p>
PUT and DELETE responses are never cacheable.<f-note>
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-13">RFC 9110 Section 9.3.4</a>,
<a href="https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.5-7">Section 9.3.5</a>
</f-note>


<h3>Navigation</h3>


<h2>Justification</h2>

<p>
CRUD not complete; uniform interface not complete

<p>
Let you use routers better

<p>
Many server frameworks support it

<p>
Encourage HTML writing

<p>
Encourage same-origin (and other security stuff)

<p>
Lots of perf gains to be had with better HTTP method use

caching?

<h2>Ecosystem Demand</h2>


<h2>History</h2>


<h2>Alternatives and Optional Proposals</h2>
<h3 id=delete-bodyies>Optional: DELETE request bodies</h3>
<p>
There's no inherent reason why a DELETE request couldn't send body content, and many popular
frameworks, like ExpressJS, do support it. Nor is DELETE content expressly prohibited by the spec,
which allows for such requests if the origin server has indicated that it supports them.
Since most HTML forms are same-origin, it could sense to allow the form to indicate that it would be
fine with DELETE content,

<p>
A <code>usebody</code> attribute could be included to indicate support. If present, the form
would send its data as part of the body, for DELETE (or GET) requests; it would be ignored for all
other methods.

<section class=footnotes>
<h2>Footnotes</h2>
</section>


<script>
class Footnote extends HTMLElement {
  static numFootnotes = 0

  connectedCallback() {
    Footnote.numFootnotes += 1

    this.content = this.innerHTML
    this.num = Footnote.numFootnotes
    this.innerHTML = `<sup id="fn-${this.num}"><a href="#ref-${this.num}">[${this.num}]</a></sup>`
  }
}

customElements.define('f-note', Footnote)

// Create footnotes
const footnotesSection = document.querySelector('section.footnotes')
const footnotes = document.querySelectorAll('f-note')
for (footnote of footnotes) {
  const p = document.createElement('p')
  p.classList.add('footnote')
  p.id = `ref-${footnote.num}`
  p.innerHTML = `[${footnote.num}] ${footnote.content} <a href="#fn-${footnote.num}">â†©</a>`
  footnotesSection.append(p)
}

// Create table of contents
const toc = document.querySelector('details.toc')
const headings = document.querySelectorAll('h2,h3')
const topList = document.createElement('ol')
let currentH2
for (heading of headings) {
  heading.id = heading.innerText.replace(' ', '-')
  if (heading.tagName === 'H2') {
    currentH2 = document.createElement('li')
    currentH2.innerHTML = `<a href="#${heading.id}">${heading.innerText}</a><ol></ol>`
    topList.append(currentH2)
  } else {
    const h2Sublist = currentH2.querySelector('ol')
    const h3Item = document.createElement('li')
    h3Item.innerHTML = `<a href="#${heading.id}">${heading.innerText}</a><ol></ol>`
    h2Sublist.append(h3Item)
  }
}
toc.append(topList)

</script>

<!-- https://www.rfc-editor.org/rfc/rfc9110.html#section-9.3.4-10 -->
